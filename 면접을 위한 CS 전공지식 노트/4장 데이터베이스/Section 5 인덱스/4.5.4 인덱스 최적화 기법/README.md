# 인덱스 최적화 기법
인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같기 때문에 특정 데이터베이스를 기준으로 설명해도 무방하다. 이 책에서는 MongoDB를 기반으로 인덱스 최적화 기법을 설명하며, 이를 기반으로 데이터베이스에 웬만큼 적용할 수 있다.<br/>

1. 인덱스는 비용이다.<br/>
먼저 인덱스는 두 번 탐색하도록 강요한다. 인덱스 리스트, 그 다음 컬렉션 순으로 탐색하기 때문이며, 관련 읽기 비용이 들게 된다.<br/>
또한, 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다. 마치 책의 본문이 수정되었을 때 목차나 찾아보기도 수정해야 하듯이 말이다. 이때 B-Tree의 높이를 균형 있게 조절하는 비용도 필요하고, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 된다.<br/>
그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아니다. 또한, 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.<br/>

2. 항상 테스팅하라<br/>
인덱스 최적화 기법은 서비스 특징에 따라 달라진다. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문이다. 그렇기 때문에 항상 테스팅하는 것이 중요하다. explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 한다.<br/>
참고로 MySQL에서는 다음과 같은 코드로 테스팅을 수행한다.<br/>
<br/>
EXPLAIN<br/>
SELECT * FROM t1<br/>
JOIN t2 ON t1.c1 = t2.c1<br/>
<br/>
3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.<br/>
보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다. <br/>
같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 한다.<br/>

1) 어떠한 값과 같음을 비교하는 ==이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다.<br/>
2) 정렬에 쓰는 필드라면 그 다음 인덱스로 설정한다.<br/>
3) 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다.<br/>
4) 유니크한 값의 정도를 카디널리티라고 한다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다.
